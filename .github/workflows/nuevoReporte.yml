name: Simple Milestone Report

on:
  workflow_dispatch:
    inputs:
      organization:
        description: 'Organization/User to analyze'
        required: true
        default: 'mauriciojim'

jobs:
  milestone-report:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: read
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Generate Milestone Report
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const targetOrg = '${{ github.event.inputs.organization || 'mauriciojim' }}';
          
          console.log(`üöÄ Generating milestone report for ${targetOrg}`);
          
          // Get all repositories for the user/organization
          let repositories = [];
          try {
            const user = await github.rest.users.getByUsername({ username: targetOrg });
            const repos = await github.rest.repos.listForUser({
              username: targetOrg,
              type: 'public',
              per_page: 100
            });
            repositories = repos.data;
          } catch (error) {
            console.log(`Could not fetch user repos, trying organization...`);
            try {
              const repos = await github.rest.repos.listForOrg({
                org: targetOrg,
                type: 'public',
                per_page: 100
              });
              repositories = repos.data;
            } catch (orgError) {
              console.log(`Error fetching repositories: ${orgError.message}`);
              return;
            }
          }
          
          console.log(`üìä Found ${repositories.length} repositories`);
          
          // Collect milestone data with issues
          let allMilestones = [];
          let totalMilestones = 0;
          let completedMilestones = 0;
          let overdueMilestones = 0;
          
          for (const repo of repositories) {
            try {
              console.log(`Processing ${repo.name}...`);
              
              // Get milestones for this repository
              const milestones = await github.rest.issues.listMilestones({
                owner: repo.owner.login,
                repo: repo.name,
                state: 'all'
              });
              
              for (const milestone of milestones.data) {
                totalMilestones++;
                
                const totalIssues = milestone.open_issues + milestone.closed_issues;
                const progress = totalIssues > 0 ? Math.round((milestone.closed_issues / totalIssues) * 100) : 0;
                
                // Check if milestone is overdue
                const isOverdue = milestone.due_on && 
                  milestone.state === 'open' && 
                  new Date(milestone.due_on) < new Date();
                
                if (milestone.state === 'closed') {
                  completedMilestones++;
                }
                if (isOverdue) {
                  overdueMilestones++;
                }
                
                // Get issues for this milestone
                console.log(`  Getting issues for milestone: ${milestone.title}`);
                let milestoneIssues = [];
                try {
                  const issues = await github.rest.issues.listForRepo({
                    owner: repo.owner.login,
                    repo: repo.name,
                    milestone: milestone.number,
                    state: 'all',
                    per_page: 100
                  });
                  
                  milestoneIssues = issues.data.map(issue => ({
                    number: issue.number,
                    title: issue.title,
                    state: issue.state,
                    url: issue.html_url,
                    assignee: issue.assignee ? issue.assignee.login : null,
                    labels: issue.labels.map(label => label.name),
                    created_at: issue.created_at,
                    updated_at: issue.updated_at,
                    closed_at: issue.closed_at
                  }));
                  
                  console.log(`    Found ${milestoneIssues.length} issues`);
                } catch (issueError) {
                  console.log(`    Error getting issues: ${issueError.message}`);
                }
                
                allMilestones.push({
                  repository: repo.name,
                  title: milestone.title,
                  state: milestone.state,
                  openIssues: milestone.open_issues,
                  closedIssues: milestone.closed_issues,
                  totalIssues: totalIssues,
                  progress: progress,
                  dueDate: milestone.due_on,
                  isOverdue: isOverdue,
                  url: milestone.html_url,
                  description: milestone.description,
                  issues: milestoneIssues
                });
              }
            } catch (error) {
              console.log(`Error processing ${repo.name}: ${error.message}`);
            }
          }
          
          // Generate report
          const now = new Date();
          let report = `# üìä Milestone Progress Report\n\n`;
          report += `**Organization/User:** ${targetOrg}\n`;
          report += `**Generated:** ${now.toISOString().split('T')[0]} ${now.toTimeString().split(' ')[0]} UTC\n\n`;
          
          // Summary
          report += `## üìà Summary\n\n`;
          report += `- **Total Repositories:** ${repositories.length}\n`;
          report += `- **Total Milestones:** ${totalMilestones}\n`;
          report += `- **Completed Milestones:** ${completedMilestones}\n`;
          report += `- **Overdue Milestones:** ${overdueMilestones}\n\n`;
          
          if (allMilestones.length === 0) {
            report += `## ‚ÑπÔ∏è No Milestones Found\n\n`;
            report += `No milestones were found in the analyzed repositories.\n`;
          } else {
            // Function to determine project name from repository
            function getProjectName(repoName) {
              console.log(`Processing repo: ${repoName}`);
              
              // OPTION 1: Single Project Mode (Default)
              // Uncomment this line to group ALL repositories into one project:
              return 'Main Project';
              
              // OPTION 2: Custom Project Mapping
              // Add your specific repository mappings here:
              const projectMappings = {
                // Example mappings - customize these for your repos:
                // 'docker-react': 'Frontend',
                // 'docker-api': 'Backend',
                // 'maven-pipeline': 'CI/CD',
                // 'simple-java-maven-app': 'Backend'
              };
              
              if (projectMappings[repoName]) {
                console.log(`  -> Mapped to ${projectMappings[repoName]} project`);
                return projectMappings[repoName];
              }
              
              // OPTION 3: Auto-detection (Current Logic)
              // Group by common prefixes
              if (repoName.startsWith('docker-')) {
                console.log(`  -> Grouped as Docker project`);
                return 'docker';
              }
              if (repoName.startsWith('maven-') || repoName.includes('maven')) {
                console.log(`  -> Grouped as Maven project`);
                return 'maven';
              }
              if (repoName.startsWith('microservice-') || repoName.startsWith('ms-')) {
                console.log(`  -> Grouped as Microservice project`);
                return 'microservice';
              }
              if (repoName.startsWith('api-') || repoName.endsWith('-api')) {
                console.log(`  -> Grouped as API project`);
                return 'api';
              }
              if (repoName.includes('frontend') || repoName.includes('react') || repoName.includes('angular') || repoName.includes('vue')) {
                console.log(`  -> Grouped as Frontend project`);
                return 'frontend';
              }
              if (repoName.includes('backend') || repoName.includes('server')) {
                console.log(`  -> Grouped as Backend project`);
                return 'backend';
              }
              if (repoName.includes('java') || repoName.includes('spring')) {
                console.log(`  -> Grouped as Java project`);
                return 'java';
              }
              
              // OPTION 4: Single Project Fallback
              // If no patterns match, group everything as one project
              console.log(`  -> Using single project mode: Main Project`);
              return 'Main Project';
            }
            
            // Group milestones by project
            const projectGroups = {};
            allMilestones.forEach(milestone => {
              const projectName = getProjectName(milestone.repository);
              if (!projectGroups[projectName]) {
                projectGroups[projectName] = {
                  repositories: new Set(),
                  milestones: []
                };
              }
              projectGroups[projectName].repositories.add(milestone.repository);
              projectGroups[projectName].milestones.push(milestone);
            });
            
            // Debug: Show project groupings
            console.log(`\nüìä Project Groupings:`);
            Object.keys(projectGroups).forEach(projectName => {
              const repos = Array.from(projectGroups[projectName].repositories);
              console.log(`  ${projectName}: ${repos.join(', ')} (${projectGroups[projectName].milestones.length} milestones)`);
            });
            
            // Milestones by project
            report += `## üéØ Project Progress Report\n\n`;
            Object.keys(projectGroups).sort().forEach(projectName => {
              const projectData = projectGroups[projectName];
              const milestones = projectData.milestones;
              const repositories = Array.from(projectData.repositories);
              
              // Calculate overall progress for this project
              const totalIssues = milestones.reduce((sum, m) => sum + m.totalIssues, 0);
              const completedIssues = milestones.reduce((sum, m) => sum + m.closedIssues, 0);
              const overallProgress = totalIssues > 0 ? Math.round((completedIssues / totalIssues) * 100) : 0;
              
              // Count milestones by state
              const openMilestones = milestones.filter(m => m.state === 'open').length;
              const closedMilestones = milestones.filter(m => m.state === 'closed').length;
              const overdueMilestones = milestones.filter(m => m.isOverdue).length;
              
              report += `### üöÄ ${projectName.charAt(0).toUpperCase() + projectName.slice(1)}\n\n`;
              report += `**Overall Progress:** ${overallProgress}% (${completedIssues}/${totalIssues} tasks completed)\n`;
              report += `**Repositories:** ${repositories.join(', ')}\n`;
              report += `**Milestones:** ${milestones.length} total ‚Ä¢ ${openMilestones} open ‚Ä¢ ${closedMilestones} closed`;
              if (overdueMilestones > 0) {
                report += ` ‚Ä¢ ${overdueMilestones} overdue ‚ö†Ô∏è`;
              }
              report += `\n\n`;
              
              // Sort milestones by due date, then by milestone name
              milestones.sort((a, b) => {
                if (a.dueDate && b.dueDate) {
                  const dateCompare = new Date(a.dueDate) - new Date(b.dueDate);
                  if (dateCompare !== 0) return dateCompare;
                }
                if (a.dueDate && !b.dueDate) return -1;
                if (!a.dueDate && b.dueDate) return 1;
                return a.title.localeCompare(b.title);
              });
              
              // Display each milestone and its tasks
              milestones.forEach(milestone => {
                const statusEmoji = milestone.isOverdue ? 'üî¥' : 
                                  milestone.state === 'open' ? 'üü°' : 'üü¢';
                const dueDate = milestone.dueDate ? 
                  milestone.dueDate.split('T')[0] : 'No due date';
                
                report += `#### ${statusEmoji} [${milestone.title}](${milestone.url})\n`;
                report += `**Repository:** ${milestone.repository} | `;
                report += `**Progress:** ${milestone.progress}% (${milestone.closedIssues}/${milestone.totalIssues}) | `;
                report += `**Due:** ${dueDate} | `;
                report += `**Status:** ${milestone.state}\n\n`;
                
                // Show milestone description if available
                if (milestone.description && milestone.description.trim()) {
                  report += `*${milestone.description.trim()}*\n\n`;
                }
                
                // Tasks/Issues table
                if (milestone.issues && milestone.issues.length > 0) {
                  report += `**Tasks:**\n\n`;
                  report += `| # | Task | Status | Assignee | Labels |\n`;
                  report += `|---|------|--------|----------|--------|\n`;
                  
                  // Sort issues: open first, then by number
                  milestone.issues.sort((a, b) => {
                    if (a.state !== b.state) {
                      return a.state === 'open' ? -1 : 1;
                    }
                    return a.number - b.number;
                  });
                  
                  milestone.issues.forEach(issue => {
                    const taskEmoji = issue.state === 'open' ? '‚è≥' : '‚úÖ';
                    const assignee = issue.assignee || 'Unassigned';
                    const labels = issue.labels.length > 0 ? issue.labels.join(', ') : '-';
                    
                    report += `| [#${issue.number}](${issue.url}) | `;
                    report += `${taskEmoji} ${issue.title} | `;
                    report += `${issue.state} | `;
                    report += `${assignee} | `;
                    report += `${labels} |\n`;
                  });
                  
                  report += `\n`;
                } else {
                  report += `*No tasks found for this milestone.*\n\n`;
                }
                
                report += `---\n\n`;
              });
            });
            
          }
          
          // Create reports directory and save file
          const reportsDir = 'reports';
          if (!fs.existsSync(reportsDir)) {
            fs.mkdirSync(reportsDir, { recursive: true });
          }
          
          fs.writeFileSync(`${reportsDir}/milestone-report.md`, report);
          
          // Create summary for issue
          let summary = `## üìä Project Milestone Summary\n\n`;
          summary += `**Key Metrics:**\n`;
          summary += `- Repositories analyzed: ${repositories.length}\n`;
          summary += `- Total milestones: ${totalMilestones}\n`;
          summary += `- Completed: ${completedMilestones}\n`;
          summary += `- Overdue: ${overdueMilestones} ${overdueMilestones > 0 ? '‚ö†Ô∏è' : '‚úÖ'}\n\n`;
          
          if (overdueMilestones > 0) {
            summary += `### ‚ö†Ô∏è Attention Required\n`;
            summary += `There are ${overdueMilestones} overdue milestone(s) that need attention.\n\n`;
          }
          
          summary += `üìã [View Full Report](./reports/milestone-report.md)\n`;
          summary += `üîÑ Report generated on ${now.toISOString().split('T')[0]}`;
          
          fs.writeFileSync(`${reportsDir}/milestone-summary.md`, summary);
          
          console.log(`‚úÖ Report generated successfully!`);
          console.log(`üìä Analyzed ${repositories.length} repositories`);
          console.log(`üéØ Found ${totalMilestones} milestones`);
          
          if (overdueMilestones > 0) {
            console.log(`‚ö†Ô∏è ${overdueMilestones} milestone(s) are overdue!`);
          }
          
          // Store summary for issue creation
          core.setOutput('summary', summary);
          core.setOutput('overdue_count', overdueMilestones);
          core.setOutput('total_milestones', totalMilestones);
          
    - name: Commit and push report
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add reports/
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "üìä Update milestone report - $(date '+%Y-%m-%d %H:%M')"
          git push
        fi
        
    - name: Create Summary Issue
      uses: actions/github-script@v7
      continue-on-error: true
      with:
        script: |
          try {
            const fs = require('fs');
            const summaryPath = 'reports/milestone-summary.md';
            
            if (fs.existsSync(summaryPath)) {
              const summary = fs.readFileSync(summaryPath, 'utf8');
              
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `üìä Milestone Report - ${new Date().toISOString().split('T')[0]}`,
                body: summary,
                labels: ['report', 'milestone', 'automated']
              });
              
              console.log(`‚úÖ Issue created successfully: ${issue.data.html_url}`);
            } else {
              console.log('‚ö†Ô∏è Summary file not found, skipping issue creation');
            }
          } catch (error) {
            console.log(`‚ö†Ô∏è Could not create issue: ${error.message}`);
            console.log('This is normal if the repository doesn\'t have issues enabled or lacks permissions');
          }
