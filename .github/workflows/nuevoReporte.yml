name: Simple Milestone Report

on:
  workflow_dispatch:
    inputs:
      organization:
        description: 'Organization/User to analyze'
        required: true
        default: 'mauriciojim'

jobs:
  milestone-report:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: read
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Generate Milestone Report
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const targetOrg = '${{ github.event.inputs.organization || 'mauriciojim' }}';
          
          console.log(`üöÄ Generating milestone report for ${targetOrg}`);
          
          // Get all repositories for the user/organization
          let repositories = [];
          try {
            const user = await github.rest.users.getByUsername({ username: targetOrg });
            const repos = await github.rest.repos.listForUser({
              username: targetOrg,
              type: 'public',
              per_page: 100
            });
            repositories = repos.data;
          } catch (error) {
            console.log(`Could not fetch user repos, trying organization...`);
            try {
              const repos = await github.rest.repos.listForOrg({
                org: targetOrg,
                type: 'public',
                per_page: 100
              });
              repositories = repos.data;
            } catch (orgError) {
              console.log(`Error fetching repositories: ${orgError.message}`);
              return;
            }
          }
          
          console.log(`üìä Found ${repositories.length} repositories`);
          
          // Collect milestone data
          let allMilestones = [];
          let totalMilestones = 0;
          let completedMilestones = 0;
          let overdueMilestones = 0;
          
          for (const repo of repositories) {
            try {
              console.log(`Processing ${repo.name}...`);
              
              // Get milestones for this repository
              const milestones = await github.rest.issues.listMilestones({
                owner: repo.owner.login,
                repo: repo.name,
                state: 'all'
              });
              
              for (const milestone of milestones.data) {
                totalMilestones++;
                
                const totalIssues = milestone.open_issues + milestone.closed_issues;
                const progress = totalIssues > 0 ? Math.round((milestone.closed_issues / totalIssues) * 100) : 0;
                
                // Check if milestone is overdue
                const isOverdue = milestone.due_on && 
                  milestone.state === 'open' && 
                  new Date(milestone.due_on) < new Date();
                
                if (milestone.state === 'closed') {
                  completedMilestones++;
                }
                if (isOverdue) {
                  overdueMilestones++;
                }
                
                allMilestones.push({
                  repository: repo.name,
                  title: milestone.title,
                  state: milestone.state,
                  openIssues: milestone.open_issues,
                  closedIssues: milestone.closed_issues,
                  totalIssues: totalIssues,
                  progress: progress,
                  dueDate: milestone.due_on,
                  isOverdue: isOverdue,
                  url: milestone.html_url,
                  description: milestone.description
                });
              }
            } catch (error) {
              console.log(`Error processing ${repo.name}: ${error.message}`);
            }
          }
          
          // Generate report
          const now = new Date();
          let report = `# üìä Milestone Progress Report\n\n`;
          report += `**Organization/User:** ${targetOrg}\n`;
          report += `**Generated:** ${now.toISOString().split('T')[0]} ${now.toTimeString().split(' ')[0]} UTC\n\n`;
          
          // Summary
          report += `## üìà Summary\n\n`;
          report += `- **Total Repositories:** ${repositories.length}\n`;
          report += `- **Total Milestones:** ${totalMilestones}\n`;
          report += `- **Completed Milestones:** ${completedMilestones}\n`;
          report += `- **Overdue Milestones:** ${overdueMilestones}\n\n`;
          
          if (allMilestones.length === 0) {
            report += `## ‚ÑπÔ∏è No Milestones Found\n\n`;
            report += `No milestones were found in the analyzed repositories.\n`;
          } else {
            // Function to determine project name from repository
            function getProjectName(repoName) {
              // Extract project patterns - customize these rules as needed
              
              // Pattern 1: Remove common suffixes
              let projectName = repoName
                .replace(/-api$|-backend$|-frontend$|-web$|-app$|-service$/, '')
                .replace(/-client$|-server$|-admin$|-dashboard$/, '');
              
              // Pattern 2: Group by common prefixes
              if (repoName.startsWith('microservice-') || repoName.startsWith('ms-')) {
                projectName = repoName.replace(/^(microservice-|ms-)/, '');
              }
              
              // Pattern 3: Group by technology/framework
              if (repoName.includes('react') || repoName.includes('angular') || repoName.includes('vue')) {
                projectName = repoName.replace(/(react|angular|vue)-?/, '').replace(/-?(react|angular|vue)/, '') || repoName;
              }
              
              if (repoName.includes('java') || repoName.includes('maven') || repoName.includes('spring')) {
                projectName = repoName.replace(/(java|maven|spring)-?/, '').replace(/-?(java|maven|spring)/, '') || repoName;
              }
              
              // Pattern 4: Default grouping - use base name
              projectName = projectName.replace(/^(docker|k8s|kubernetes)-?/, '').replace(/-?(docker|k8s|kubernetes)/, '') || repoName;
              
              // If after all processing it's empty, use original name
              return projectName || repoName;
            }
            
            // Group milestones by project
            const projectGroups = {};
            allMilestones.forEach(milestone => {
              const projectName = getProjectName(milestone.repository);
              if (!projectGroups[projectName]) {
                projectGroups[projectName] = {
                  repositories: new Set(),
                  milestones: []
                };
              }
              projectGroups[projectName].repositories.add(milestone.repository);
              projectGroups[projectName].milestones.push(milestone);
            });
            
            // Milestones by project
            report += `## üéØ Progress by Project\n\n`;
            Object.keys(projectGroups).sort().forEach(projectName => {
              const projectData = projectGroups[projectName];
              const milestones = projectData.milestones;
              const repositories = Array.from(projectData.repositories);
              
              // Calculate overall progress for this project
              const totalIssues = milestones.reduce((sum, m) => sum + m.totalIssues, 0);
              const completedIssues = milestones.reduce((sum, m) => sum + m.closedIssues, 0);
              const overallProgress = totalIssues > 0 ? Math.round((completedIssues / totalIssues) * 100) : 0;
              
              // Count milestones by state
              const openMilestones = milestones.filter(m => m.state === 'open').length;
              const closedMilestones = milestones.filter(m => m.state === 'closed').length;
              const overdueMilestones = milestones.filter(m => m.isOverdue).length;
              
              report += `### ÔøΩ ${projectName.charAt(0).toUpperCase() + projectName.slice(1)} Project\n\n`;
              report += `**Project Progress:** ${overallProgress}% (${completedIssues}/${totalIssues} issues)\n`;
              report += `**Repositories:** ${repositories.join(', ')}\n`;
              report += `**Milestones:** ${milestones.length} total ‚Ä¢ ${openMilestones} open ‚Ä¢ ${closedMilestones} closed`;
              if (overdueMilestones > 0) {
                report += ` ‚Ä¢ ${overdueMilestones} overdue ‚ö†Ô∏è`;
              }
              report += `\n\n`;
              
              // Table for this project's milestones
              report += `| Milestone | Repository | State | Progress | Due Date | Status |\n`;
              report += `|-----------|------------|-------|----------|----------|--------|\n`;
              
              // Sort milestones by due date, then by milestone name, then by repository
              milestones.sort((a, b) => {
                // First by due date
                if (a.dueDate && b.dueDate) {
                  const dateCompare = new Date(a.dueDate) - new Date(b.dueDate);
                  if (dateCompare !== 0) return dateCompare;
                }
                if (a.dueDate && !b.dueDate) return -1;
                if (!a.dueDate && b.dueDate) return 1;
                
                // Then by milestone name
                const nameCompare = a.title.localeCompare(b.title);
                if (nameCompare !== 0) return nameCompare;
                
                // Finally by repository
                return a.repository.localeCompare(b.repository);
              });
              
              milestones.forEach(milestone => {
                const statusEmoji = milestone.isOverdue ? 'üî¥' : 
                                  milestone.state === 'open' ? 'üü°' : 'üü¢';
                const dueDate = milestone.dueDate ? 
                  milestone.dueDate.split('T')[0] : 'No due date';
                
                report += `| [${milestone.title}](${milestone.url}) | `;
                report += `${milestone.repository} | `;
                report += `${milestone.state} | `;
                report += `${milestone.progress}% (${milestone.closedIssues}/${milestone.totalIssues}) | `;
                report += `${dueDate} | `;
                report += `${statusEmoji} |\n`;
              });
              
              report += `\n`;
            });
            
            // Summary by milestone name (cross-project view)
            const milestoneGroups = {};
            allMilestones.forEach(milestone => {
              if (!milestoneGroups[milestone.title]) {
                milestoneGroups[milestone.title] = [];
              }
              milestoneGroups[milestone.title].push(milestone);
            });
            
            // Only show cross-project view if there are shared milestone names
            const sharedMilestones = Object.keys(milestoneGroups).filter(name => 
              milestoneGroups[name].length > 1
            );
            
            if (sharedMilestones.length > 0) {
              report += `## üîÑ Cross-Project Milestones\n\n`;
              report += `*Milestones that appear across multiple projects:*\n\n`;
              
              sharedMilestones.sort().forEach(milestoneName => {
                const milestones = milestoneGroups[milestoneName];
                
                // Calculate overall progress for this milestone across projects
                const totalIssues = milestones.reduce((sum, m) => sum + m.totalIssues, 0);
                const completedIssues = milestones.reduce((sum, m) => sum + m.closedIssues, 0);
                const overallProgress = totalIssues > 0 ? Math.round((completedIssues / totalIssues) * 100) : 0;
                
                // Group by projects for this milestone
                const projectsForMilestone = {};
                milestones.forEach(m => {
                  const projName = getProjectName(m.repository);
                  if (!projectsForMilestone[projName]) {
                    projectsForMilestone[projName] = [];
                  }
                  projectsForMilestone[projName].push(m);
                });
                
                report += `### ${milestoneName}\n\n`;
                report += `**Overall Progress:** ${overallProgress}% (${completedIssues}/${totalIssues} issues across ${Object.keys(projectsForMilestone).length} projects)\n\n`;
                
                // Table
                report += `| Project | Repository | State | Progress | Due Date | Status |\n`;
                report += `|---------|------------|-------|----------|----------|--------|\n`;
                
                Object.keys(projectsForMilestone).sort().forEach(projName => {
                  projectsForMilestone[projName].forEach(milestone => {
                    const statusEmoji = milestone.isOverdue ? 'üî¥' : 
                                      milestone.state === 'open' ? 'üü°' : 'üü¢';
                    const dueDate = milestone.dueDate ? 
                      milestone.dueDate.split('T')[0] : 'No due date';
                    
                    report += `| ${projName} | `;
                    report += `[${milestone.repository}](${milestone.url}) | `;
                    report += `${milestone.state} | `;
                    report += `${milestone.progress}% (${milestone.closedIssues}/${milestone.totalIssues}) | `;
                    report += `${dueDate} | `;
                    report += `${statusEmoji} |\n`;
                  });
                });
                
                report += `\n`;
              });
            }
          }
          
          // Create reports directory and save file
          const reportsDir = 'reports';
          if (!fs.existsSync(reportsDir)) {
            fs.mkdirSync(reportsDir, { recursive: true });
          }
          
          fs.writeFileSync(`${reportsDir}/milestone-report.md`, report);
          
          // Create summary for issue
          let summary = `## üìä Weekly Milestone Summary\n\n`;
          summary += `**Key Metrics:**\n`;
          summary += `- Repositories analyzed: ${repositories.length}\n`;
          summary += `- Total milestones: ${totalMilestones}\n`;
          summary += `- Completed: ${completedMilestones}\n`;
          summary += `- Overdue: ${overdueMilestones} ${overdueMilestones > 0 ? '‚ö†Ô∏è' : '‚úÖ'}\n\n`;
          
          if (overdueMilestones > 0) {
            summary += `### ‚ö†Ô∏è Attention Required\n`;
            summary += `There are ${overdueMilestones} overdue milestone(s) that need attention.\n\n`;
          }
          
          summary += `üìã [View Full Report](./reports/milestone-report.md)\n`;
          summary += `üîÑ Report generated automatically on ${now.toISOString().split('T')[0]}`;
          
          fs.writeFileSync(`${reportsDir}/milestone-summary.md`, summary);
          
          console.log(`‚úÖ Report generated successfully!`);
          console.log(`üìä Analyzed ${repositories.length} repositories`);
          console.log(`üéØ Found ${totalMilestones} milestones`);
          
          if (overdueMilestones > 0) {
            console.log(`‚ö†Ô∏è ${overdueMilestones} milestone(s) are overdue!`);
          }
          
          // Store summary for issue creation
          core.setOutput('summary', summary);
          core.setOutput('overdue_count', overdueMilestones);
          core.setOutput('total_milestones', totalMilestones);
          
    - name: Commit and push report
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add reports/
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "üìä Update milestone report - $(date '+%Y-%m-%d %H:%M')"
          git push
        fi
        
    - name: Create Summary Issue
      uses: actions/github-script@v7
      continue-on-error: true
      with:
        script: |
          try {
            const fs = require('fs');
            const summaryPath = 'reports/milestone-summary.md';
            
            if (fs.existsSync(summaryPath)) {
              const summary = fs.readFileSync(summaryPath, 'utf8');
              
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `üìä Milestone Report - ${new Date().toISOString().split('T')[0]}`,
                body: summary,
                labels: ['report', 'milestone', 'automated']
              });
              
              console.log(`‚úÖ Issue created successfully: ${issue.data.html_url}`);
            } else {
              console.log('‚ö†Ô∏è Summary file not found, skipping issue creation');
            }
          } catch (error) {
            console.log(`‚ö†Ô∏è Could not create issue: ${error.message}`);
            console.log('This is normal if the repository doesn\'t have issues enabled or lacks permissions');
          }
